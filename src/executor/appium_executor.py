# src/executor/appium_executor.py
# -*- coding: utf-8 -*-
"""
Appium-based executor for AR interaction events.

This module wraps your existing Appium + gesture utilities
in `common/device.py` and `common/actions.py` and exposes:

- snapshot_screen() -> np.ndarray (BGR image)
- perform(op, region, params) -> None

`region` is expected to be a dict like:
{
    "target_id": int,
    "bbox": [x, y, w, h],         # usually in window coords
    "center_xy": [cx, cy],
    "region_type": "on_object" | "off_object",
    ...
}

`params` is an op-specific parameter dict generated by the sampler.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import numpy as np

from ..common import actions, device


@dataclass
class ExecutorConfig:
    """Lightweight config holder for the executor."""
    device_serial: Optional[str]
    app_package: str
    app_activity: Optional[str]
    warmup_wait: float = 3.0

    default_tap_ms: int = 80
    default_drag_ms: int = 300
    default_rotate_ms: int = 400
    default_pinch_ms: int = 400


class AppiumExecutor:
    """
    High-level executor that wraps an Appium driver and your gesture
    primitives (tap/drag/pinch/rotate).

    Design:
      - Executor only understands a few primitive action *families*:
        'tap', 'drag', 'rotate', 'pinch'.
      - High-level ops like 'drag_short', 'rotate_cw', 'pinch_small'
        should be reduced to these families via ACTION_FAMILY mapping.
      - All semantic differences (short/long/clockwise/...) should be
        handled in the sampler by generating different `params`.
    """

    # 映射高层 op 名称 -> 原子 family
    # 需要新增高层动作时，只改这里即可（以及 sampler 中的参数生成逻辑）
    ACTION_FAMILY: Dict[str, str] = {
        "tap": "tap",
        "single_tap": "tap",

        "drag": "drag",
        "drag_short": "drag",
        "drag_long": "drag",

        "rotate": "rotate",
        "rotate_cw": "rotate",
        "rotate_ccw": "rotate",

        "pinch": "pinch",
        "pinch_in": "pinch",
        "pinch_out": "pinch",
        "zoom_in": "pinch",
        "zoom_out": "pinch",
    }

    def __init__(
        self,
        cfg: Dict[str, Any],
        device_id: Optional[str] = None,
        driver: Optional[Any] = None,
    ) -> None:
        """
        Args:
            cfg: Global config dict (parsed from YAML).
            device_id: Optional override for device serial/udid.
            driver: Optional existing Appium driver.
        """
        # 设备串号优先级：显式传入 > cfg["device_serial"] > cfg["device"]
        serial = device_id or cfg.get("device_serial") or cfg.get("device")

        app_cfg = cfg.get("app", {})
        pkg = app_cfg.get("package")
        activity = app_cfg.get("activity", "auto")

        if not pkg:
            raise ValueError(
                "AppiumExecutor: cfg['app']['package'] is required to launch the app."
            )

        self.config = ExecutorConfig(
            device_serial=serial,
            app_package=pkg,
            app_activity=activity,
            warmup_wait=float(cfg.get("runtime", {}).get("warmup_wait", 3.0)),
            default_tap_ms=int(cfg.get("runtime", {}).get("default_tap_ms", 80)),
            default_drag_ms=int(cfg.get("runtime", {}).get("default_drag_ms", 300)),
            default_rotate_ms=int(cfg.get("runtime", {}).get("default_rotate_ms", 400)),
            default_pinch_ms=int(cfg.get("runtime", {}).get("default_pinch_ms", 400)),
        )

        if driver is not None:
            self.driver = driver
        else:
            self.driver = self._build_driver(self.config)

    # ------------------------------------------------------------------ #
    # Driver construction: 使用 common.device.make_driver :contentReference[oaicite:2]{index=2}
    # ------------------------------------------------------------------ #
    def _build_driver(self, cfg: ExecutorConfig) -> Any:
        """
        Create an Appium driver session using your existing helper.
        """
        drv = device.make_driver(
            pkg=cfg.app_package,
            activity=cfg.app_activity,
            serial=cfg.device_serial,
            warmup_wait=cfg.warmup_wait,
        )
        return drv

    # ------------------------------------------------------------------ #
    # Screenshot interface: 使用 device.capture_bgr
    # ------------------------------------------------------------------ #
    def snapshot_screen(self) -> np.ndarray:
        """
        Capture the current screen as a BGR np.ndarray (H x W x 3, uint8).
        """
        img_bgr = device.capture_bgr(self.driver)
        if img_bgr is None:
            raise RuntimeError("device.capture_bgr returned None.")
        return img_bgr

    # ------------------------------------------------------------------ #
    # Operation execution
    # ------------------------------------------------------------------ #
    def perform(self, op: str, region: Dict[str, Any], params: Dict[str, Any]) -> None:
        """
        Execute a single interaction event on the device.

        Args:
            op: High-level operation type, e.g. 'tap', 'drag', 'rotate',
                'pinch_in', 'rotate_cw', 'drag_short', etc.
            region: Target region dict (bbox + center_xy + metadata).
            params: Operation-specific parameters generated by sampler.

        Design:
          - First, reduce `op` to a primitive family via ACTION_FAMILY.
          - Then, dispatch to the corresponding helper method.
        """
        op = op.lower()
        family = self.ACTION_FAMILY.get(op, op)

        if family == "tap":
            self._do_tap(region, params)
        elif family == "drag":
            self._do_drag(region, params)
        elif family == "rotate":
            self._do_rotate(region, params, op=op)
        elif family == "pinch":
            self._do_pinch(region, params, op=op)
        else:
            raise ValueError(f"Unsupported op type (family={family}, op={op})")

    # ------------------------------------------------------------------ #
    # Helpers
    # ------------------------------------------------------------------ #
    def _get_center(self, region: Dict[str, Any]) -> Tuple[float, float]:
        """
        Get the center of the region in window coordinates.

        For now we assume `center_xy` / `bbox` are already in window coords.
        If later you want to use image coords from detector, you can
        add a mapping here (参考 v2_ar_monkey_appium.py 里的 _map_img_to_window) :contentReference[oaicite:3]{index=3}
        """
        cx, cy = region.get("center_xy", [None, None])
        if cx is None or cy is None:
            x, y, w, h = region["bbox"]
            cx = x + w / 2.0
            cy = y + h / 2.0
        return float(cx), float(cy)

    # -------------------------- tap ----------------------------------- #
    def _do_tap(self, region: Dict[str, Any], params: Dict[str, Any]) -> None:
        cx, cy = self._get_center(region)
        duration_ms = int(params.get("duration_ms", self.config.default_tap_ms))

        dx = float(params.get("dx", 0.0))
        dy = float(params.get("dy", 0.0))
        x = cx + dx
        y = cy + dy

        actions.tap(
            driver=self.driver,
            x=int(x),
            y=int(y),
            press_ms=duration_ms,
        )

    # -------------------------- drag ---------------------------------- #
    def _do_drag(self, region: Dict[str, Any], params: Dict[str, Any]) -> None:
        cx, cy = self._get_center(region)
        duration_ms = int(params.get("duration_ms", self.config.default_drag_ms))

        # sampler 负责生成 dx, dy，Executor 只负责执行
        dx = float(params.get("dx", 0.0))
        dy = float(params.get("dy", 0.0))

        x1 = cx
        y1 = cy
        x2 = cx + dx
        y2 = cy + dy

        actions.drag_line(
            driver=self.driver,
            x1=int(x1),
            y1=int(y1),
            x2=int(x2),
            y2=int(y2),
            duration_ms=duration_ms,
        )

    # -------------------------- rotate -------------------------------- #
    def _do_rotate(self, region: Dict[str, Any], params: Dict[str, Any], op: str) -> None:
        cx, cy = self._get_center(region)
        duration_ms = int(params.get("duration_ms", self.config.default_rotate_ms))

        angle_deg = float(params.get("angle_deg", 60.0))
        radius_px = float(params.get("radius_px", 200.0))
        steps = int(params.get("steps", 8))

        # 高层 op 可以通过 op 名控制方向，比如 rotate_cw / rotate_ccw
        direction = str(params.get("direction", "ccw"))
        if op == "rotate_cw":
            direction = "cw"
        elif op == "rotate_ccw":
            direction = "ccw"

        start_deg = float(params.get("start_deg", 0.0))

        actions.rotate(
            driver=self.driver,
            cx=cx,
            cy=cy,
            radius=radius_px,
            angle_deg=angle_deg,
            duration_ms=duration_ms,
            steps=steps,
            direction=direction,
            start_deg=start_deg,
        )

    # -------------------------- pinch / zoom -------------------------- #
    def _do_pinch(self, region: Dict[str, Any], params: Dict[str, Any], op: str) -> None:
        cx, cy = self._get_center(region)
        duration_ms = int(params.get("duration_ms", self.config.default_pinch_ms))

        # primitive: pinch_or_zoom(driver, cx, cy, start_dist, end_dist, duration_ms)
        start_dist = params.get("start_dist", None)
        end_dist = params.get("end_dist", None)

        if start_dist is None or end_dist is None:
            # 用相对参数转换成距离
            radius_px = float(params.get("radius_px", 160.0))
            base_scale = float(params.get("base_scale", 0.2))

            # 高层 op 例如 pinch_in, pinch_out / zoom_in, zoom_out
            if op in ("pinch_in", "zoom_out"):
                scale_sign = -1
            elif op in ("pinch_out", "zoom_in"):
                scale_sign = +1
            else:
                scale_sign = int(params.get("scale_sign", +1))

            start_dist = float(params.get("start_dist", 2.0 * radius_px))
            end_dist = float(start_dist * (1.0 + scale_sign * base_scale))

        actions.pinch_or_zoom(
            driver=self.driver,
            cx=int(cx),
            cy=int(cy),
            start_dist=int(start_dist),
            end_dist=int(end_dist),
            duration_ms=duration_ms,
        )
